import{C as X}from"./codemirror.es-a8349234.js";import{o as Le}from"./types.es-a471f408.js";import{C as Me,R as pe,P}from"./Range.es-9e9b9946.js";import{t as h,d as oe,i as se,T as de,v as me,a as Ye}from"./index-c6badf58.js";import"./index-5db1c28a.js";import{U as S,b as ge,c as w,V as Te,d as $,W as F,s as R,z as N,X as B,Y as qe,Z as Be,t as b,a as U,i as y,y as j,B as Xe,l as Ge,m as Ee,n as C,h as ve,_ as k,I as Je,$ as Qe,a0 as Ke,a1 as We,v as He,p as ze,g as Ze,C as Ne,a2 as xe}from"./store-1cf665bf.js";import{K as u,G as d,j as I,i as T,D as E,O as G,d as en,p as nn}from"./parser-0b83345b.js";import{a as tn,b as x,c as rn,d as on,e as sn}from"./predicates-408eacef.js";import"./interface-41bd3122.js";import"./engine-25e09f19.js";import"./workbenchContext-f25dff9b.js";import"./index-1359143a.js";import"./lock-75972ea0.js";import"./variable-a27e8ccb.js";import"./common-7ac8785d.js";import"./hotkey-3a258436.js";import"./Breadcrumb-2e0ae14b.js";import"./DownOutlined-92418081.js";import"./index-92618001.js";import"./LeftOutlined-bae698e2.js";import"./PurePanel-52451c94.js";import"./index-3302fb41.js";import"./index-515b3c33.js";import"./EditFilled-a24d3d64.js";import"./index-9acb7ce5.js";import"./index-c8bc8bc1.js";import"./index-200e4422.js";import"./useShowArrow-c557106f.js";import"./index-f5739ea0.js";import"./main-7459389b.js";import"./toNumber-de19fe10.js";import"./utils-9cc409ea.js";import"./dayjs.min-099ebaef.js";import"./utils-9b986f1e.js";import"./DeleteOutlined-fbbb6184.js";import"./index-df721c55.js";import"./index-9c967405.js";import"./index-b4bdf0fc.js";import"./index-dd69e0db.js";import"./index-ea2358d0.js";import"./PlusOutlined-022acd15.js";import"./index-455a984b.js";import"./index-4a4483d6.js";import"./index-27f7d322.js";import"./globalContext-4bde4d89.js";function ye(e){return{Document(n){for(const t of n.definitions)if(!tn(t)){const r=t.kind===u.SCHEMA_DEFINITION||t.kind===u.SCHEMA_EXTENSION?"schema":'"'+t.name.value+'"';e.reportError(new d(`The ${r} definition is not executable.`,{nodes:t}))}return!1}}}function an(e){return{Field(n){const t=e.getParentType();if(t&&!e.getFieldDef()){const i=e.getSchema(),o=n.name.value;let a=S("to use an inline fragment on",ln(i,t,o));a===""&&(a=S(cn(t,o))),e.reportError(new d(`Cannot query field "${o}" on type "${t.name}".`+a,{nodes:n}))}}}}function ln(e,n,t){if(!ge(n))return[];const r=new Set,i=Object.create(null);for(const a of e.getPossibleTypes(n))if(a.getFields()[t]){r.add(a),i[a.name]=1;for(const s of a.getInterfaces()){var o;s.getFields()[t]&&(r.add(s),i[s.name]=((o=i[s.name])!==null&&o!==void 0?o:0)+1)}}return[...r].sort((a,s)=>{const l=i[s.name]-i[a.name];return l!==0?l:w(a)&&e.isSubType(a,s)?-1:w(s)&&e.isSubType(s,a)?1:Te(a.name,s.name)}).map(a=>a.name)}function cn(e,n){if($(e)||w(e)){const t=Object.keys(e.getFields());return F(n,t)}return[]}function un(e){return{InlineFragment(n){const t=n.typeCondition;if(t){const r=h(e.getSchema(),t);if(r&&!R(r)){const i=N(t);e.reportError(new d(`Fragment cannot condition on non composite type "${i}".`,{nodes:t}))}}},FragmentDefinition(n){const t=h(e.getSchema(),n.typeCondition);if(t&&!R(t)){const r=N(n.typeCondition);e.reportError(new d(`Fragment "${n.name.value}" cannot condition on non composite type "${r}".`,{nodes:n.typeCondition}))}}}}function fn(e){return{...pn(e),Argument(n){const t=e.getArgument(),r=e.getFieldDef(),i=e.getParentType();if(!t&&r&&i){const o=n.name.value,a=r.args.map(l=>l.name),s=F(o,a);e.reportError(new d(`Unknown argument "${o}" on field "${i.name}.${r.name}".`+S(s),{nodes:n}))}}}}function pn(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():B;for(const a of r)n[a.name]=a.args.map(s=>s.name);const i=e.getDocument().definitions;for(const a of i)if(a.kind===u.DIRECTIVE_DEFINITION){var o;const s=(o=a.arguments)!==null&&o!==void 0?o:[];n[a.name.value]=s.map(l=>l.name.value)}return{Directive(a){const s=a.name.value,l=n[s];if(a.arguments&&l)for(const c of a.arguments){const f=c.name.value;if(!l.includes(f)){const p=F(f,l);e.reportError(new d(`Unknown argument "${f}" on directive "@${s}".`+S(p),{nodes:c}))}}return!1}}}function Ie(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():B;for(const o of r)n[o.name]=o.locations;const i=e.getDocument().definitions;for(const o of i)o.kind===u.DIRECTIVE_DEFINITION&&(n[o.name.value]=o.locations.map(a=>a.value));return{Directive(o,a,s,l,c){const f=o.name.value,p=n[f];if(!p){e.reportError(new d(`Unknown directive "@${f}".`,{nodes:o}));return}const m=dn(c);m&&!p.includes(m)&&e.reportError(new d(`Directive "@${f}" may not be used on ${m}.`,{nodes:o}))}}}function dn(e){const n=e[e.length-1];switch("kind"in n||I(!1),n.kind){case u.OPERATION_DEFINITION:return mn(n.operation);case u.FIELD:return E.FIELD;case u.FRAGMENT_SPREAD:return E.FRAGMENT_SPREAD;case u.INLINE_FRAGMENT:return E.INLINE_FRAGMENT;case u.FRAGMENT_DEFINITION:return E.FRAGMENT_DEFINITION;case u.VARIABLE_DEFINITION:return E.VARIABLE_DEFINITION;case u.SCHEMA_DEFINITION:case u.SCHEMA_EXTENSION:return E.SCHEMA;case u.SCALAR_TYPE_DEFINITION:case u.SCALAR_TYPE_EXTENSION:return E.SCALAR;case u.OBJECT_TYPE_DEFINITION:case u.OBJECT_TYPE_EXTENSION:return E.OBJECT;case u.FIELD_DEFINITION:return E.FIELD_DEFINITION;case u.INTERFACE_TYPE_DEFINITION:case u.INTERFACE_TYPE_EXTENSION:return E.INTERFACE;case u.UNION_TYPE_DEFINITION:case u.UNION_TYPE_EXTENSION:return E.UNION;case u.ENUM_TYPE_DEFINITION:case u.ENUM_TYPE_EXTENSION:return E.ENUM;case u.ENUM_VALUE_DEFINITION:return E.ENUM_VALUE;case u.INPUT_OBJECT_TYPE_DEFINITION:case u.INPUT_OBJECT_TYPE_EXTENSION:return E.INPUT_OBJECT;case u.INPUT_VALUE_DEFINITION:{const t=e[e.length-3];return"kind"in t||I(!1),t.kind===u.INPUT_OBJECT_TYPE_DEFINITION?E.INPUT_FIELD_DEFINITION:E.ARGUMENT_DEFINITION}default:I(!1,"Unexpected kind: "+T(n.kind))}}function mn(e){switch(e){case G.QUERY:return E.QUERY;case G.MUTATION:return E.MUTATION;case G.SUBSCRIPTION:return E.SUBSCRIPTION}}function he(e){return{FragmentSpread(n){const t=n.name.value;e.getFragment(t)||e.reportError(new d(`Unknown fragment "${t}".`,{nodes:n.name}))}}}function be(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);for(const o of e.getDocument().definitions)x(o)&&(r[o.name.value]=!0);const i=[...Object.keys(t),...Object.keys(r)];return{NamedType(o,a,s,l,c){const f=o.name.value;if(!t[f]&&!r[f]){var p;const m=(p=c[2])!==null&&p!==void 0?p:s,g=m!=null&&gn(m);if(g&&ae.includes(f))return;const v=F(f,g?ae.concat(i):i);e.reportError(new d(`Unknown type "${f}".`+S(v),{nodes:o}))}}}}const ae=[...qe,...Be].map(e=>e.name);function gn(e){return"kind"in e&&(rn(e)||on(e))}function Tn(e){let n=0;return{Document(t){n=t.definitions.filter(r=>r.kind===u.OPERATION_DEFINITION).length},OperationDefinition(t){!t.name&&n>1&&e.reportError(new d("This anonymous operation must be the only defined operation.",{nodes:t}))}}}function En(e){var n,t,r;const i=e.getSchema(),o=(n=(t=(r=i==null?void 0:i.astNode)!==null&&r!==void 0?r:i==null?void 0:i.getQueryType())!==null&&t!==void 0?t:i==null?void 0:i.getMutationType())!==null&&n!==void 0?n:i==null?void 0:i.getSubscriptionType();let a=0;return{SchemaDefinition(s){if(o){e.reportError(new d("Cannot define a new schema within a schema extension.",{nodes:s}));return}a>0&&e.reportError(new d("Must provide only one schema definition.",{nodes:s})),++a}}}function vn(e){const n=Object.create(null),t=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(o){return i(o),!1}};function i(o){if(n[o.name.value])return;const a=o.name.value;n[a]=!0;const s=e.getFragmentSpreads(o.selectionSet);if(s.length!==0){r[a]=t.length;for(const l of s){const c=l.name.value,f=r[c];if(t.push(l),f===void 0){const p=e.getFragment(c);p&&i(p)}else{const p=t.slice(f),m=p.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");e.reportError(new d(`Cannot spread fragment "${c}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:p}))}t.pop()}r[a]=void 0}}}function Nn(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const r=e.getRecursiveVariableUsages(t);for(const{node:i}of r){const o=i.name.value;n[o]!==!0&&e.reportError(new d(t.name?`Variable "$${o}" is not defined by operation "${t.name.value}".`:`Variable "$${o}" is not defined.`,{nodes:[i,t]}))}}},VariableDefinition(t){n[t.variable.name.value]=!0}}}function De(e){const n=[],t=[];return{OperationDefinition(r){return n.push(r),!1},FragmentDefinition(r){return t.push(r),!1},Document:{leave(){const r=Object.create(null);for(const i of n)for(const o of e.getRecursivelyReferencedFragments(i))r[o.name.value]=!0;for(const i of t){const o=i.name.value;r[o]!==!0&&e.reportError(new d(`Fragment "${o}" is never used.`,{nodes:i}))}}}}}function yn(e){let n=[];return{OperationDefinition:{enter(){n=[]},leave(t){const r=Object.create(null),i=e.getRecursiveVariableUsages(t);for(const{node:o}of i)r[o.name.value]=!0;for(const o of n){const a=o.variable.name.value;r[a]!==!0&&e.reportError(new d(t.name?`Variable "$${a}" is never used in operation "${t.name.value}".`:`Variable "$${a}" is never used.`,{nodes:o}))}}},VariableDefinition(t){n.push(t)}}}function ee(e){switch(e.kind){case u.OBJECT:return{...e,fields:In(e.fields)};case u.LIST:return{...e,values:e.values.map(ee)};case u.INT:case u.FLOAT:case u.STRING:case u.BOOLEAN:case u.NULL:case u.ENUM:case u.VARIABLE:return e}}function In(e){return e.map(n=>({...n,value:ee(n.value)})).sort((n,t)=>Te(n.name.value,t.name.value))}function Oe(e){return Array.isArray(e)?e.map(([n,t])=>`subfields "${n}" conflict because `+Oe(t)).join(" and "):e}function hn(e){const n=new wn,t=new Map;return{SelectionSet(r){const i=bn(e,t,n,e.getParentType(),r);for(const[[o,a],s,l]of i){const c=Oe(a);e.reportError(new d(`Fields "${o}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:s.concat(l)}))}}}}function bn(e,n,t,r,i){const o=[],[a,s]=Y(e,n,r,i);if(On(e,o,n,t,a),s.length!==0)for(let l=0;l<s.length;l++){L(e,o,n,t,!1,a,s[l]);for(let c=l+1;c<s.length;c++)M(e,o,n,t,!1,s[l],s[c])}return o}function L(e,n,t,r,i,o,a){const s=e.getFragment(a);if(!s)return;const[l,c]=K(e,t,s);if(o!==l){ne(e,n,t,r,i,o,l);for(const f of c)r.has(f,a,i)||(r.add(f,a,i),L(e,n,t,r,i,o,f))}}function M(e,n,t,r,i,o,a){if(o===a||r.has(o,a,i))return;r.add(o,a,i);const s=e.getFragment(o),l=e.getFragment(a);if(!s||!l)return;const[c,f]=K(e,t,s),[p,m]=K(e,t,l);ne(e,n,t,r,i,c,p);for(const g of m)M(e,n,t,r,i,o,g);for(const g of f)M(e,n,t,r,i,g,a)}function Dn(e,n,t,r,i,o,a,s){const l=[],[c,f]=Y(e,n,i,o),[p,m]=Y(e,n,a,s);ne(e,l,n,t,r,c,p);for(const g of m)L(e,l,n,t,r,c,g);for(const g of f)L(e,l,n,t,r,p,g);for(const g of f)for(const v of m)M(e,l,n,t,r,g,v);return l}function On(e,n,t,r,i){for(const[o,a]of Object.entries(i))if(a.length>1)for(let s=0;s<a.length;s++)for(let l=s+1;l<a.length;l++){const c=Se(e,t,r,!1,o,a[s],a[l]);c&&n.push(c)}}function ne(e,n,t,r,i,o,a){for(const[s,l]of Object.entries(o)){const c=a[s];if(c)for(const f of l)for(const p of c){const m=Se(e,t,r,i,s,f,p);m&&n.push(m)}}}function Se(e,n,t,r,i,o,a){const[s,l,c]=o,[f,p,m]=a,g=r||s!==f&&$(s)&&$(f);if(!g){const A=l.name.value,ie=p.name.value;if(A!==ie)return[[i,`"${A}" and "${ie}" are different fields`],[l],[p]];if(!Sn(l,p))return[[i,"they have differing arguments"],[l],[p]]}const v=c==null?void 0:c.type,_=m==null?void 0:m.type;if(v&&_&&Q(v,_))return[[i,`they return conflicting types "${T(v)}" and "${T(_)}"`],[l],[p]];const te=l.selectionSet,re=p.selectionSet;if(te&&re){const A=Dn(e,n,t,g,b(v),te,b(_),re);return _n(A,i,l,p)}}function Sn(e,n){const t=e.arguments,r=n.arguments;if(t===void 0||t.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||t.length!==r.length)return!1;const i=new Map(r.map(({name:o,value:a})=>[o.value,a]));return t.every(o=>{const a=o.value,s=i.get(o.name.value);return s===void 0?!1:le(a)===le(s)})}function le(e){return N(ee(e))}function Q(e,n){return U(e)?U(n)?Q(e.ofType,n.ofType):!0:U(n)?!0:y(e)?y(n)?Q(e.ofType,n.ofType):!0:y(n)?!0:j(e)||j(n)?e!==n:!1}function Y(e,n,t,r){const i=n.get(r);if(i)return i;const o=Object.create(null),a=Object.create(null);_e(e,t,r,o,a);const s=[o,Object.keys(a)];return n.set(r,s),s}function K(e,n,t){const r=n.get(t.selectionSet);if(r)return r;const i=h(e.getSchema(),t.typeCondition);return Y(e,n,i,t.selectionSet)}function _e(e,n,t,r,i){for(const o of t.selections)switch(o.kind){case u.FIELD:{const a=o.name.value;let s;($(n)||w(n))&&(s=n.getFields()[a]);const l=o.alias?o.alias.value:a;r[l]||(r[l]=[]),r[l].push([n,o,s]);break}case u.FRAGMENT_SPREAD:i[o.name.value]=!0;break;case u.INLINE_FRAGMENT:{const a=o.typeCondition,s=a?h(e.getSchema(),a):n;_e(e,s,o.selectionSet,r,i);break}}}function _n(e,n,t,r){if(e.length>0)return[[n,e.map(([i])=>i)],[t,...e.map(([,i])=>i).flat()],[r,...e.map(([,,i])=>i).flat()]]}class wn{constructor(){this._data=new Map}has(n,t,r){var i;const[o,a]=n<t?[n,t]:[t,n],s=(i=this._data.get(o))===null||i===void 0?void 0:i.get(a);return s===void 0?!1:r?!0:r===s}add(n,t,r){const[i,o]=n<t?[n,t]:[t,n],a=this._data.get(i);a===void 0?this._data.set(i,new Map([[o,r]])):a.set(o,r)}}function $n(e){return{InlineFragment(n){const t=e.getType(),r=e.getParentType();if(R(t)&&R(r)&&!oe(e.getSchema(),t,r)){const i=T(r),o=T(t);e.reportError(new d(`Fragment cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:n}))}},FragmentSpread(n){const t=n.name.value,r=Fn(e,t),i=e.getParentType();if(r&&i&&!oe(e.getSchema(),r,i)){const o=T(i),a=T(r);e.reportError(new d(`Fragment "${t}" cannot be spread here as objects of type "${o}" can never be of type "${a}".`,{nodes:n}))}}}}function Fn(e,n){const t=e.getFragment(n);if(t){const r=h(e.getSchema(),t.typeCondition);if(R(r))return r}}function Rn(e){const n=e.getSchema(),t=Object.create(null);for(const i of e.getDocument().definitions)x(i)&&(t[i.name.value]=i);return{ScalarTypeExtension:r,ObjectTypeExtension:r,InterfaceTypeExtension:r,UnionTypeExtension:r,EnumTypeExtension:r,InputObjectTypeExtension:r};function r(i){const o=i.name.value,a=t[o],s=n==null?void 0:n.getType(o);let l;if(a?l=Cn[a.kind]:s&&(l=An(s)),l){if(l!==i.kind){const c=Vn(i.kind);e.reportError(new d(`Cannot extend non-${c} type "${o}".`,{nodes:a?[a,i]:i}))}}else{const c=Object.keys({...t,...n==null?void 0:n.getTypeMap()}),f=F(o,c);e.reportError(new d(`Cannot extend type "${o}" because it is not defined.`+S(f),{nodes:i.name}))}}}const Cn={[u.SCALAR_TYPE_DEFINITION]:u.SCALAR_TYPE_EXTENSION,[u.OBJECT_TYPE_DEFINITION]:u.OBJECT_TYPE_EXTENSION,[u.INTERFACE_TYPE_DEFINITION]:u.INTERFACE_TYPE_EXTENSION,[u.UNION_TYPE_DEFINITION]:u.UNION_TYPE_EXTENSION,[u.ENUM_TYPE_DEFINITION]:u.ENUM_TYPE_EXTENSION,[u.INPUT_OBJECT_TYPE_DEFINITION]:u.INPUT_OBJECT_TYPE_EXTENSION};function An(e){if(Xe(e))return u.SCALAR_TYPE_EXTENSION;if($(e))return u.OBJECT_TYPE_EXTENSION;if(w(e))return u.INTERFACE_TYPE_EXTENSION;if(Ge(e))return u.UNION_TYPE_EXTENSION;if(Ee(e))return u.ENUM_TYPE_EXTENSION;if(C(e))return u.INPUT_OBJECT_TYPE_EXTENSION;I(!1,"Unexpected type: "+T(e))}function Vn(e){switch(e){case u.SCALAR_TYPE_EXTENSION:return"scalar";case u.OBJECT_TYPE_EXTENSION:return"object";case u.INTERFACE_TYPE_EXTENSION:return"interface";case u.UNION_TYPE_EXTENSION:return"union";case u.ENUM_TYPE_EXTENSION:return"enum";case u.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:I(!1,"Unexpected kind: "+T(e))}}function Un(e){return{...Pn(e),Field:{leave(n){var t;const r=e.getFieldDef();if(!r)return!1;const i=new Set((t=n.arguments)===null||t===void 0?void 0:t.map(o=>o.name.value));for(const o of r.args)if(!i.has(o.name)&&ve(o)){const a=T(o.type);e.reportError(new d(`Field "${r.name}" argument "${o.name}" of type "${a}" is required, but it was not provided.`,{nodes:n}))}}}}}function Pn(e){var n;const t=Object.create(null),r=e.getSchema(),i=(n=r==null?void 0:r.getDirectives())!==null&&n!==void 0?n:B;for(const s of i)t[s.name]=k(s.args.filter(ve),l=>l.name);const o=e.getDocument().definitions;for(const s of o)if(s.kind===u.DIRECTIVE_DEFINITION){var a;const l=(a=s.arguments)!==null&&a!==void 0?a:[];t[s.name.value]=k(l.filter(jn),c=>c.name.value)}return{Directive:{leave(s){const l=s.name.value,c=t[l];if(c){var f;const p=(f=s.arguments)!==null&&f!==void 0?f:[],m=new Set(p.map(g=>g.name.value));for(const[g,v]of Object.entries(c))if(!m.has(g)){const _=Je(v.type)?T(v.type):N(v.type);e.reportError(new d(`Directive "@${l}" argument "${g}" of type "${_}" is required, but it was not provided.`,{nodes:s}))}}}}}}function jn(e){return e.type.kind===u.NON_NULL_TYPE&&e.defaultValue==null}function kn(e){return{Field(n){const t=e.getType(),r=n.selectionSet;if(t){if(j(b(t))){if(r){const i=n.name.value,o=T(t);e.reportError(new d(`Field "${i}" must not have a selection since type "${o}" has no subfields.`,{nodes:r}))}}else if(!r){const i=n.name.value,o=T(t);e.reportError(new d(`Field "${i}" of type "${o}" must have a selection of subfields. Did you mean "${i} { ... }"?`,{nodes:n}))}}}}}function Ln(e,n,t){var r;const i={},o=(r=n.arguments)!==null&&r!==void 0?r:[],a=k(o,s=>s.name.value);for(const s of e.args){const l=s.name,c=s.type,f=a[l];if(!f){if(s.defaultValue!==void 0)i[l]=s.defaultValue;else if(y(c))throw new d(`Argument "${l}" of required type "${T(c)}" was not provided.`,{nodes:n});continue}const p=f.value;let m=p.kind===u.NULL;if(p.kind===u.VARIABLE){const v=p.name.value;if(t==null||!Mn(t,v)){if(s.defaultValue!==void 0)i[l]=s.defaultValue;else if(y(c))throw new d(`Argument "${l}" of required type "${T(c)}" was provided the variable "$${v}" which was not provided a runtime value.`,{nodes:p});continue}m=t[v]==null}if(m&&y(c))throw new d(`Argument "${l}" of non-null type "${T(c)}" must not be null.`,{nodes:p});const g=Qe(p,c,t);if(g===void 0)throw new d(`Argument "${l}" has invalid value ${N(p)}.`,{nodes:p});i[l]=g}return i}function ce(e,n,t){var r;const i=(r=n.directives)===null||r===void 0?void 0:r.find(o=>o.name.value===e.name);if(i)return Ln(e,i,t)}function Mn(e,n){return Object.prototype.hasOwnProperty.call(e,n)}function Yn(e,n,t,r,i){const o=new Map;return W(e,n,t,r,i,o,new Set),o}function W(e,n,t,r,i,o,a){for(const s of i.selections)switch(s.kind){case u.FIELD:{if(!J(t,s))continue;const l=qn(s),c=o.get(l);c!==void 0?c.push(s):o.set(l,[s]);break}case u.INLINE_FRAGMENT:{if(!J(t,s)||!ue(e,s,r))continue;W(e,n,t,r,s.selectionSet,o,a);break}case u.FRAGMENT_SPREAD:{const l=s.name.value;if(a.has(l)||!J(t,s))continue;a.add(l);const c=n[l];if(!c||!ue(e,c,r))continue;W(e,n,t,r,c.selectionSet,o,a);break}}}function J(e,n){const t=ce(Ke,n,e);if((t==null?void 0:t.if)===!0)return!1;const r=ce(We,n,e);return(r==null?void 0:r.if)!==!1}function ue(e,n,t){const r=n.typeCondition;if(!r)return!0;const i=h(e,r);return i===t?!0:ge(i)?e.isSubType(i,t):!1}function qn(e){return e.alias?e.alias.value:e.name.value}function Bn(e){return{OperationDefinition(n){if(n.operation==="subscription"){const t=e.getSchema(),r=t.getSubscriptionType();if(r){const i=n.name?n.name.value:null,o=Object.create(null),a=e.getDocument(),s=Object.create(null);for(const c of a.definitions)c.kind===u.FRAGMENT_DEFINITION&&(s[c.name.value]=c);const l=Yn(t,s,o,r,n.selectionSet);if(l.size>1){const p=[...l.values()].slice(1).flat();e.reportError(new d(i!=null?`Subscription "${i}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:p}))}for(const c of l.values())c[0].name.value.startsWith("__")&&e.reportError(new d(i!=null?`Subscription "${i}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:c}))}}}}}function we(e,n){const t=new Map;for(const r of e){const i=n(r),o=t.get(i);o===void 0?t.set(i,[r]):o.push(r)}return t}function $e(e){return{Field:n,Directive:n};function n(t){var r;const i=(r=t.arguments)!==null&&r!==void 0?r:[],o=we(i,a=>a.name.value);for(const[a,s]of o)s.length>1&&e.reportError(new d(`There can be only one argument named "${a}".`,{nodes:s.map(l=>l.name)}))}}function Xn(e){const n=Object.create(null),t=e.getSchema();return{DirectiveDefinition(r){const i=r.name.value;if(t!=null&&t.getDirective(i)){e.reportError(new d(`Directive "@${i}" already exists in the schema. It cannot be redefined.`,{nodes:r.name}));return}return n[i]?e.reportError(new d(`There can be only one directive named "@${i}".`,{nodes:[n[i],r.name]})):n[i]=r.name,!1}}}function Fe(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():B;for(const s of r)n[s.name]=!s.isRepeatable;const i=e.getDocument().definitions;for(const s of i)s.kind===u.DIRECTIVE_DEFINITION&&(n[s.name.value]=!s.repeatable);const o=Object.create(null),a=Object.create(null);return{enter(s){if(!("directives"in s)||!s.directives)return;let l;if(s.kind===u.SCHEMA_DEFINITION||s.kind===u.SCHEMA_EXTENSION)l=o;else if(x(s)||sn(s)){const c=s.name.value;l=a[c],l===void 0&&(a[c]=l=Object.create(null))}else l=Object.create(null);for(const c of s.directives){const f=c.name.value;n[f]&&(l[f]?e.reportError(new d(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],c]})):l[f]=c)}}}}function Gn(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);return{EnumTypeDefinition:i,EnumTypeExtension:i};function i(o){var a;const s=o.name.value;r[s]||(r[s]=Object.create(null));const l=(a=o.values)!==null&&a!==void 0?a:[],c=r[s];for(const f of l){const p=f.name.value,m=t[s];Ee(m)&&m.getValue(p)?e.reportError(new d(`Enum value "${s}.${p}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):c[p]?e.reportError(new d(`Enum value "${s}.${p}" can only be defined once.`,{nodes:[c[p],f.name]})):c[p]=f.name}return!1}}function Jn(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);return{InputObjectTypeDefinition:i,InputObjectTypeExtension:i,InterfaceTypeDefinition:i,InterfaceTypeExtension:i,ObjectTypeDefinition:i,ObjectTypeExtension:i};function i(o){var a;const s=o.name.value;r[s]||(r[s]=Object.create(null));const l=(a=o.fields)!==null&&a!==void 0?a:[],c=r[s];for(const f of l){const p=f.name.value;Qn(t[s],p)?e.reportError(new d(`Field "${s}.${p}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):c[p]?e.reportError(new d(`Field "${s}.${p}" can only be defined once.`,{nodes:[c[p],f.name]})):c[p]=f.name}return!1}}function Qn(e,n){return $(e)||w(e)||C(e)?e.getFields()[n]!=null:!1}function Kn(e){const n=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(t){const r=t.name.value;return n[r]?e.reportError(new d(`There can be only one fragment named "${r}".`,{nodes:[n[r],t.name]})):n[r]=t.name,!1}}}function Re(e){const n=[];let t=Object.create(null);return{ObjectValue:{enter(){n.push(t),t=Object.create(null)},leave(){const r=n.pop();r||I(!1),t=r}},ObjectField(r){const i=r.name.value;t[i]?e.reportError(new d(`There can be only one input field named "${i}".`,{nodes:[t[i],r.name]})):t[i]=r.name}}}function Wn(e){const n=Object.create(null);return{OperationDefinition(t){const r=t.name;return r&&(n[r.value]?e.reportError(new d(`There can be only one operation named "${r.value}".`,{nodes:[n[r.value],r]})):n[r.value]=r),!1},FragmentDefinition:()=>!1}}function Hn(e){const n=e.getSchema(),t=Object.create(null),r=n?{query:n.getQueryType(),mutation:n.getMutationType(),subscription:n.getSubscriptionType()}:{};return{SchemaDefinition:i,SchemaExtension:i};function i(o){var a;const s=(a=o.operationTypes)!==null&&a!==void 0?a:[];for(const l of s){const c=l.operation,f=t[c];r[c]?e.reportError(new d(`Type for ${c} already defined in the schema. It cannot be redefined.`,{nodes:l})):f?e.reportError(new d(`There can be only one ${c} type in schema.`,{nodes:[f,l]})):t[c]=l}return!1}}function zn(e){const n=Object.create(null),t=e.getSchema();return{ScalarTypeDefinition:r,ObjectTypeDefinition:r,InterfaceTypeDefinition:r,UnionTypeDefinition:r,EnumTypeDefinition:r,InputObjectTypeDefinition:r};function r(i){const o=i.name.value;if(t!=null&&t.getType(o)){e.reportError(new d(`Type "${o}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:i.name}));return}return n[o]?e.reportError(new d(`There can be only one type named "${o}".`,{nodes:[n[o],i.name]})):n[o]=i.name,!1}}function Zn(e){return{OperationDefinition(n){var t;const r=(t=n.variableDefinitions)!==null&&t!==void 0?t:[],i=we(r,o=>o.variable.name.value);for(const[o,a]of i)a.length>1&&e.reportError(new d(`There can be only one variable named "$${o}".`,{nodes:a.map(s=>s.variable.name)}))}}}function xn(e){return{ListValue(n){const t=He(e.getParentInputType());if(!U(t))return O(e,n),!1},ObjectValue(n){const t=b(e.getInputType());if(!C(t))return O(e,n),!1;const r=k(n.fields,i=>i.name.value);for(const i of Object.values(t.getFields()))if(!r[i.name]&&ze(i)){const a=T(i.type);e.reportError(new d(`Field "${t.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:n}))}},ObjectField(n){const t=b(e.getParentInputType());if(!e.getInputType()&&C(t)){const i=F(n.name.value,Object.keys(t.getFields()));e.reportError(new d(`Field "${n.name.value}" is not defined by type "${t.name}".`+S(i),{nodes:n}))}},NullValue(n){const t=e.getInputType();y(t)&&e.reportError(new d(`Expected value of type "${T(t)}", found ${N(n)}.`,{nodes:n}))},EnumValue:n=>O(e,n),IntValue:n=>O(e,n),FloatValue:n=>O(e,n),StringValue:n=>O(e,n),BooleanValue:n=>O(e,n)}}function O(e,n){const t=e.getInputType();if(!t)return;const r=b(t);if(!j(r)){const i=T(t);e.reportError(new d(`Expected value of type "${i}", found ${N(n)}.`,{nodes:n}));return}try{if(r.parseLiteral(n,void 0)===void 0){const o=T(t);e.reportError(new d(`Expected value of type "${o}", found ${N(n)}.`,{nodes:n}))}}catch(i){const o=T(t);i instanceof d?e.reportError(i):e.reportError(new d(`Expected value of type "${o}", found ${N(n)}; `+i.message,{nodes:n,originalError:i}))}}function et(e){return{VariableDefinition(n){const t=h(e.getSchema(),n.type);if(t!==void 0&&!Ze(t)){const r=n.variable.name.value,i=N(n.type);e.reportError(new d(`Variable "$${r}" cannot be non-input type "${i}".`,{nodes:n.type}))}}}}function nt(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const r=e.getRecursiveVariableUsages(t);for(const{node:i,type:o,defaultValue:a}of r){const s=i.name.value,l=n[s];if(l&&o){const c=e.getSchema(),f=h(c,l.type);if(f&&!tt(c,f,l.defaultValue,o,a)){const p=T(f),m=T(o);e.reportError(new d(`Variable "$${s}" of type "${p}" used in position expecting type "${m}".`,{nodes:[l,i]}))}}}}},VariableDefinition(t){n[t.variable.name.value]=t}}}function tt(e,n,t,r,i){if(y(r)&&!y(n)){if(!(t!=null&&t.kind!==u.NULL)&&!(i!==void 0))return!1;const s=r.ofType;return se(e,n,s)}return se(e,n,r)}const Ce=Object.freeze([ye,Wn,Tn,Bn,be,un,et,kn,an,Kn,he,De,$n,vn,Zn,Nn,yn,Ie,Fe,fn,$e,xn,Un,nt,hn,Re]);class rt{constructor(n,t){this._ast=n,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=t}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(n){this._onError(n)}getDocument(){return this._ast}getFragment(n){let t;if(this._fragments)t=this._fragments;else{t=Object.create(null);for(const r of this.getDocument().definitions)r.kind===u.FRAGMENT_DEFINITION&&(t[r.name.value]=r);this._fragments=t}return t[n]}getFragmentSpreads(n){let t=this._fragmentSpreads.get(n);if(!t){t=[];const r=[n];let i;for(;i=r.pop();)for(const o of i.selections)o.kind===u.FRAGMENT_SPREAD?t.push(o):o.selectionSet&&r.push(o.selectionSet);this._fragmentSpreads.set(n,t)}return t}getRecursivelyReferencedFragments(n){let t=this._recursivelyReferencedFragments.get(n);if(!t){t=[];const r=Object.create(null),i=[n.selectionSet];let o;for(;o=i.pop();)for(const a of this.getFragmentSpreads(o)){const s=a.name.value;if(r[s]!==!0){r[s]=!0;const l=this.getFragment(s);l&&(t.push(l),i.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(n,t)}return t}}class it extends rt{constructor(n,t,r,i){super(t,i),this._schema=n,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(n){let t=this._variableUsages.get(n);if(!t){const r=[],i=new de(this._schema);Ne(n,me(i,{VariableDefinition:()=>!1,Variable(o){r.push({node:o,type:i.getInputType(),defaultValue:i.getDefaultValue()})}})),t=r,this._variableUsages.set(n,t)}return t}getRecursiveVariableUsages(n){let t=this._recursiveVariableUsages.get(n);if(!t){t=this.getVariableUsages(n);for(const r of this.getRecursivelyReferencedFragments(n))t=t.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(n,t)}return t}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Ae(e,n,t=Ce,r,i=new de(e)){var o;const a=(o=r==null?void 0:r.maxErrors)!==null&&o!==void 0?o:100;n||en(!1,"Must provide document."),Ye(e);const s=Object.freeze({}),l=[],c=new it(e,n,i,p=>{if(l.length>=a)throw l.push(new d("Too many validation errors, error limit reached. Validation aborted.")),s;l.push(p)}),f=xe(t.map(p=>p(c)));try{Ne(n,me(i,f))}catch(p){if(p!==s)throw p}return l}function ot(e){return{Field(n){const t=e.getFieldDef(),r=t==null?void 0:t.deprecationReason;if(t&&r!=null){const i=e.getParentType();i!=null||I(!1),e.reportError(new d(`The field ${i.name}.${t.name} is deprecated. ${r}`,{nodes:n}))}},Argument(n){const t=e.getArgument(),r=t==null?void 0:t.deprecationReason;if(t&&r!=null){const i=e.getDirective();if(i!=null)e.reportError(new d(`Directive "@${i.name}" argument "${t.name}" is deprecated. ${r}`,{nodes:n}));else{const o=e.getParentType(),a=e.getFieldDef();o!=null&&a!=null||I(!1),e.reportError(new d(`Field "${o.name}.${a.name}" argument "${t.name}" is deprecated. ${r}`,{nodes:n}))}}},ObjectField(n){const t=b(e.getParentInputType());if(C(t)){const r=t.getFields()[n.name.value],i=r==null?void 0:r.deprecationReason;i!=null&&e.reportError(new d(`The input field ${t.name}.${r.name} is deprecated. ${i}`,{nodes:n}))}},EnumValue(n){const t=e.getEnumValue(),r=t==null?void 0:t.deprecationReason;if(t&&r!=null){const i=b(e.getInputType());i!=null||I(!1),e.reportError(new d(`The enum value "${i.name}.${t.name}" is deprecated. ${r}`,{nodes:n}))}}}}var st=Object.defineProperty,D=(e,n)=>st(e,"name",{value:n,configurable:!0});const at=[En,Hn,zn,Gn,Jn,Xn,be,Ie,Fe,Rn,$e,Re];function Ve(e,n,t,r,i){const o=Ce.filter(s=>!(s===De||s===ye||r&&s===he));return t&&Array.prototype.push.apply(o,t),i&&Array.prototype.push.apply(o,at),Ae(e,n,o).filter(s=>{if(s.message.indexOf("Unknown directive")!==-1&&s.nodes){const l=s.nodes[0];if(l&&l.kind===u.DIRECTIVE){const c=l.name.value;if(c==="arguments"||c==="argumentDefinitions")return!1}}return!0})}D(Ve,"validateWithCustomRules");const V={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},H={[V.Error]:1,[V.Warning]:2,[V.Information]:3,[V.Hint]:4},q=D((e,n)=>{if(!e)throw new Error(n)},"invariant");function Ue(e,n=null,t,r,i){var o,a;let s=null;i&&(typeof i=="string"?e+=`

`+i:e+=`

`+i.reduce((l,c)=>(l+=N(c)+`

`,l),""));try{s=nn(e)}catch(l){if(l instanceof d){const c=je((a=(o=l.locations)===null||o===void 0?void 0:o[0])!==null&&a!==void 0?a:{line:0,column:0},e);return[{severity:H.Error,message:l.message,source:"GraphQL: Syntax",range:c}]}throw l}return Pe(s,n,t,r)}D(Ue,"getDiagnostics");function Pe(e,n=null,t,r){if(!n)return[];const i=z(Ve(n,e,t,r),a=>Z(a,H.Error,"Validation")),o=z(Ae(n,e,[ot]),a=>Z(a,H.Warning,"Deprecation"));return i.concat(o)}D(Pe,"validateQuery");function z(e,n){return Array.prototype.concat.apply([],e.map(n))}D(z,"mapCat");function Z(e,n,t){if(!e.nodes)return[];const r=[];return e.nodes.forEach(i=>{const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){q(e.locations,"GraphQL validation error requires locations.");const a=e.locations[0],s=ke(o),l=a.column+(s.end-s.start);r.push({source:`GraphQL: ${t}`,message:e.message,severity:n,range:new pe(new P(a.line-1,a.column-1),new P(a.line-1,l))})}}),r}D(Z,"annotations");function je(e,n){const t=Le(),r=t.startState(),i=n.split(`
`);q(i.length>=e.line,"Query text must have more lines than where the error happened");let o=null;for(let c=0;c<e.line;c++)for(o=new Me(i[c]);!o.eol()&&t.token(o,r)!=="invalidchar";);q(o,"Expected Parser stream to be available.");const a=e.line-1,s=o.getStartOfToken(),l=o.getCurrentPosition();return new pe(new P(a,s),new P(a,l))}D(je,"getRange");function ke(e){const t=e.loc;return q(t,"Expected ASTNode to have a location."),t}D(ke,"getLocation");const fe=["error","warning","information","hint"],lt={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};X.registerHelper("lint","graphql",(e,n)=>{const t=n.schema;return Ue(e,t,n.validationRules,void 0,n.externalFragments).map(o=>({message:o.message,severity:o.severity?fe[o.severity-1]:fe[0],type:o.source?lt[o.source]:void 0,from:X.Pos(o.range.start.line,o.range.start.character),to:X.Pos(o.range.end.line,o.range.end.character)}))});
